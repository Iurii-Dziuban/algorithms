package iurii.job.interview.codility.sixt;

import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;

/**
 * Let's say I have a database of scripts.
 * Each script has an arbitrary number of dependencies.
 * The dependencies are expressed as a list of scriptIds that need to be executed before a given script.
 * There are no circular dependencies.
 * I want to come up with an execution plan so that I can run all of the scripts in a sane order.
 * Below is the script representation.
 * <p>
 * <p>
 * In general, it is a more global problem of scheduling and executing tasks on multiple CPUs.
 * In general it is NP complete problem (Number of tasks and number of CPUs)
 * and there are only heuristic algorithms that produce more or less optimal solutions.
 * <p>
 * The simplest case of solving the order of execution,
 * so that task is executed after all tasks, it depends on, are completed
 * is using topological order sorting on graph of tasks.
 */
public class VulnerabilityScript {

    private final int scriptId;
    private final List<Integer> dependencies;

    public VulnerabilityScript(int scriptId, List<Integer> dependencies) {
        this.scriptId = scriptId;
        this.dependencies = dependencies;
    }

    public int getScriptId() {
        return scriptId;
    }

    public List<Integer> getDependencies() {
        return dependencies;
    }
}

class TopologicalSort {

    // A recursive function used by topologicalSort
    private void topologicalSortUtil(int v, boolean visited[], ArrayDeque<Integer> stack, List<VulnerabilityScript> scripts) {
        // Mark the current script as visited.
        visited[v] = true;

        // Recur for all the scripts it depends on
        for (int i : scripts.get(v).getDependencies()) {
            if (!visited[i]) {
                topologicalSortUtil(i, visited, stack, scripts);
            }
        }
        // Push current script to stack which stores result
        stack.push(v);
    }

    /**
     * Assuming that on 0 position scriptId = 0; on 1 position scriptId = 1, etc.,
     * so that scripts can be retrieved based on the id from the List (otherwise additional mapping can be used)
     *
     * Time complexity:
     * Auxiliary space complexity
     */
    public List<Integer> sort(List<VulnerabilityScript> scripts) {
        // Stack can be used instead of ArrayDeque, but ArrayDeque is better
        ArrayDeque<Integer> scriptOrderStack = new ArrayDeque<>();
        // Mark all the vertices as not visited
        int size = scripts.size();
        boolean visited[] = new boolean[size];
        for (int i = 0; i < size; i++) {
            visited[i] = false;
        }

        // Call the recursive helper function to store
        // Topological Sort starting from all vertices
        // one by one
        for (int i = 0; i < size; i++) {
            if (!visited[i]) {
                topologicalSortUtil(i, visited, scriptOrderStack, scripts);
            }
        }
        // Get content of scriptOrderStack in reverse order
        // LinkedList is used just easier to fill (Queue or ArrayList can be used)
        LinkedList<Integer> result = new LinkedList<>();
        while (!scriptOrderStack.isEmpty()) {
            result.addFirst(scriptOrderStack.pop());
        }
        return result;
    }
}